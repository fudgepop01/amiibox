import { EditController } from './editController';
export class HexEditor {
    constructor() {
        this.lineNumber = 0;
        this.displayAscii = true;
        this.maxLines = 30;
        this.bytesPerLine = 16;
        this.bytesUntilForcedLine = 0;
        this.asciiInline = false;
        this.bytesPerGroup = 4;
        this.mode = "edit";
        this.editType = "overwrite";
        this.regionDepth = 2;
        this.regions = [];
        this.scroll = (evt) => {
            evt.preventDefault();
            let scaledVelocity = (!Number.isInteger(evt.deltaY)) ? Math.ceil(evt.deltaY / 100) : Math.ceil(evt.deltaY / 2);
            if (scaledVelocity === -0)
                scaledVelocity -= 1;
            if (this.lineNumber + scaledVelocity < 0)
                this.lineNumber = 0;
            else if (this.lineNumber + scaledVelocity > Math.floor(this.editController.length / this.bytesPerLine) - 1)
                this.lineNumber = Math.floor(this.editController.length / this.bytesPerLine) - 1;
            else
                this.lineNumber += scaledVelocity;
        };
    }
    componentWillLoad() {
        this.file = new Uint8Array(32);
        this.editController = new EditController(this);
        this.regionScaleWidth = 28;
        this.regionScaleHeight = 17;
    }
    componentDidLoad() {
        this.hexLoaded.emit(this.editController);
    }
    async acceptFile(file) {
        console.log(file);
        this.fileMetadata = file;
        const reader = new FileReader();
        reader.readAsArrayBuffer(file);
        reader.onload = (event) => {
            this.file = new Uint8Array(event.target.result);
            this.editController = new EditController(this);
        };
    }
    async saveFile() {
        if (this.file == undefined)
            return;
        return this.editController.save();
    }
    async setLineNumber(newLineNumber) {
        this.lineNumber = newLineNumber;
        this.hexLineChanged.emit(newLineNumber);
    }
    async setCursorPosition(newCursorPosition) {
        this.cursor = newCursorPosition;
    }
    async setSelection(newSelection) {
        this.selection = Object.assign({}, this.selection, newSelection);
    }
    async getChunk(location, length) {
        return this.editController.render(location, length);
    }
    async getFileMetadata() {
        return this.fileMetadata;
    }
    buildHexView() {
        const { lineNumber, maxLines, bytesPerLine, bytesPerGroup, asciiInline } = this;
        const start = lineNumber * bytesPerLine;
        const chunkData = this.editController.render(start, maxLines * bytesPerLine);
        const chunk = chunkData.out;
        const addedRanges = chunkData.meta.added;
        const lines = [];
        for (let i = 0; i < maxLines; i++) {
            lines.push(chunk.subarray(i * bytesPerLine, (i + 1) * bytesPerLine));
        }
        const lineViews = [];
        const charViews = [];
        for (const [lineNum, line] of lines.entries()) {
            if (line.length === 0)
                break;
            const base = start + lineNum * bytesPerLine;
            const charLines = [];
            const hexLines = [];
            let ascii = '•';
            let selected = false;
            for (const [position, val] of [...line.values()].entries()) {
                let out;
                if (/\w|[!@#$%^&*()_+=\]\\:;"'>.<,/?]/.test(String.fromCharCode(val))) {
                    ascii = String.fromCharCode(val);
                }
                else {
                    ascii = '•';
                }
                if (asciiInline && /\w/.test(ascii)) {
                    out = "." + ascii;
                }
                else {
                    out = val.toString(16).toUpperCase().padStart(2, '0');
                }
                const classList = [];
                if (position % bytesPerGroup === bytesPerGroup - 1)
                    classList.push('padByte');
                if (this.cursor === base + position) {
                    classList.push('cursor');
                    selected = true;
                }
                if (this.selection && this.selection.start <= base + position && base + position <= this.selection.end)
                    classList.push('selected');
                for (const [start, end] of addedRanges) {
                    if (start <= base + position && base + position < end) {
                        classList.push('added');
                        break;
                    }
                }
                charLines.push(h("span", { class: classList.join(' ') }, ascii));
                hexLines.push(h("span", { class: classList.join(' ') }, out));
            }
            lineViews.push((h("div", { class: 'hexLine' + (selected ? ' selected' : '') }, hexLines)));
            charViews.push((h("div", { class: 'charLine' + (selected ? ' selected' : '') }, charLines)));
        }
        while (lineViews.length < maxLines) {
            lineViews.push(h("div", { class: "hexLine", style: { pointerEvents: 'none' } },
                h("span", null, "-")));
            charViews.push(h("div", { class: "charLine", style: { pointerEvents: 'none' } },
                h("span", null, "-")));
        }
        const lineLabels = [];
        for (let i = 0; i < maxLines; i++) {
            lineLabels.push(h("div", { class: "lineLabel", style: { pointerEvents: 'none' } }, '0x' + (start + i * bytesPerLine).toString(16).padStart(8, ' ')));
        }
        const regionMarkers = [];
        const buildRegion = (region, depth = 0, index) => {
            if (region.end < start || region.start > start + this.maxLines * this.bytesPerLine) {
                if (region.subRegions && depth + 1 !== this.regionDepth) {
                    for (const [i, r] of region.subRegions.entries())
                        buildRegion(r, depth + 1, i);
                }
                return;
            }
            ;
            if (depth === this.regionDepth)
                return;
            const s = region.start % this.bytesPerLine;
            const e = region.end % this.bytesPerLine;
            const l = Math.floor((region.end - region.start + s) / this.bytesPerLine);
            const offset = Math.floor(region.start / this.bytesPerLine) - lineNumber;
            const getColor = {
                0: ['#88F', '#BBF'],
                1: ['#F88', '#FBB'],
                2: ['#8D8', '#BDB']
            };
            regionMarkers.push((h("polygon", { onmousemove: `
            if (window.canUpdateMousemove === undefined) {
              window.canUpdateMousemove = true;
            }
            if (window.canUpdateMousemove) {
              window.canUpdateMousemove = false;
              document.documentElement.style.setProperty('--mouse-x', event.clientX);
              document.documentElement.style.setProperty('--mouse-y', event.clientY);
              document.getElementById('tooltip').setAttribute('active', true)
              document.getElementById('tooltip').setAttribute('complex', '${JSON.stringify(Object.assign({}, region, { subRegions: region.subRegions ? region.subRegions.map(sr => sr.name) : null }))}');

              setTimeout(() => {window.canUpdateMousemove = true}, 50);
            }
          `, onmouseleave: `document.getElementById('tooltip').setAttribute('active', false)`, class: "region", points: `
            0,${(1 + offset) * this.regionScaleHeight}
            ${s * this.regionScaleWidth},${(1 + offset) * this.regionScaleHeight}
            ${s * this.regionScaleWidth},${offset * this.regionScaleHeight}
            ${this.bytesPerLine * this.regionScaleWidth},${offset * this.regionScaleHeight}
            ${this.bytesPerLine * this.regionScaleWidth},${(l + offset) * this.regionScaleHeight}
            ${e * this.regionScaleWidth},${(l + offset) * this.regionScaleHeight}
            ${e * this.regionScaleWidth},${(l + offset + 1) * this.regionScaleHeight}
            0,${(l + 1 + offset) * this.regionScaleHeight}
            `, fill: region.color || getColor[depth % 3][index % 2], stroke: "none" })));
            if (region.subRegions && depth + 1 !== this.regionDepth) {
                for (const [i, r] of region.subRegions.entries())
                    buildRegion(r, depth + 1, i);
            }
        };
        for (const [i, region] of this.regions.entries()) {
            buildRegion(region, 0, i);
        }
        return {
            lineViews,
            charViews,
            lineLabels,
            regionMarkers: h("svg", { viewbox: `0 0 ${this.bytesPerLine * this.regionScaleWidth} ${this.maxLines * this.regionScaleHeight}`, width: `${this.bytesPerLine * this.regionScaleWidth}`, height: `${this.maxLines * this.regionScaleHeight}` }, regionMarkers)
        };
    }
    edit(evt) {
        if (this.editType === 'readonly')
            return;
        const editController = this.editController;
        if (!editController.inProgress)
            editController.initEdit(this.cursor, this.editType);
        editController.buildEdit(evt);
    }
    showHex() {
        const { lineViews, charViews, lineLabels, regionMarkers } = this.buildHexView();
        return (h("div", { class: "hex", onMouseEnter: (evt) => this._toggleScrollListener(evt), onMouseLeave: (evt) => this._toggleScrollListener(evt), onMouseDown: (evt) => this.beginSelection(evt), onMouseUp: (evt) => this.endSelection(evt), tabindex: "0", onKeyDown: (evt) => this.edit(evt) },
            h("div", { id: "MEASURE", class: "hex", style: { position: 'absolute', visibility: 'hidden', padding: '0 5px' } }, "AB"),
            h("div", { class: "lineLabels" }, lineLabels),
            h("div", { class: "hexView" },
                h("div", { class: "highlight", style: { position: 'absolute', top: '0', display: this.mode === 'noregion' ? 'none' : 'block', zIndex: this.mode === 'region' ? '3' : '0' } }, regionMarkers),
                h("div", { class: "main" }, lineViews)),
            this.displayAscii ?
                h("div", { class: "asciiView" }, charViews)
                : null));
    }
    beginSelection(evt) {
        if (evt.target.id === 'HEX-SCROLLBAR')
            return;
        this.tempSelection =
            this.lineNumber * this.bytesPerLine +
                [...evt.composedPath()[2].children].indexOf(evt.composedPath()[1]) * this.bytesPerLine +
                [...evt.composedPath()[1].children].indexOf(evt.composedPath()[0]);
    }
    endSelection(evt) {
        if (evt.target.id === 'HEX-SCROLLBAR')
            return;
        const chosen = this.lineNumber * this.bytesPerLine +
            [...evt.composedPath()[2].children].indexOf(evt.composedPath()[1]) * this.bytesPerLine +
            [...evt.composedPath()[1].children].indexOf(evt.composedPath()[0]);
        if (this.tempSelection > chosen) {
            this.selection = {
                start: chosen,
                end: this.tempSelection,
            };
        }
        else {
            this.selection = {
                start: this.tempSelection,
                end: chosen,
            };
        }
        this.tempSelection = null;
        this.cursor = chosen;
        this.hexCursorChanged.emit(this.cursor);
        this.hexSelectionChanged.emit(this.selection);
        if (this.editController.inProgress) {
            this.editController.commit();
            this.hexDataChanged.emit();
        }
    }
    render() {
        return (h("div", { class: "fudgedit-container" }, this.showHex()));
    }
    _toggleScrollListener(evt) {
        if (evt.type === "mouseenter")
            evt.target.addEventListener("wheel", this.scroll, { passive: false });
        else
            evt.target.removeEventListener("wheel", this.scroll, false);
    }
    static get is() { return "fudge-hex-editor"; }
    static get properties() { return {
        "acceptFile": {
            "method": true
        },
        "asciiInline": {
            "type": Boolean,
            "attr": "ascii-inline"
        },
        "bytesPerGroup": {
            "type": Number,
            "attr": "bytes-per-group"
        },
        "bytesPerLine": {
            "type": Number,
            "attr": "bytes-per-line"
        },
        "bytesUntilForcedLine": {
            "type": Number,
            "attr": "bytes-until-forced-line"
        },
        "cursor": {
            "state": true
        },
        "displayAscii": {
            "type": Boolean,
            "attr": "display-ascii"
        },
        "editType": {
            "type": String,
            "attr": "edit-type"
        },
        "file": {
            "state": true
        },
        "fileMetadata": {
            "state": true
        },
        "getChunk": {
            "method": true
        },
        "getFileMetadata": {
            "method": true
        },
        "lineNumber": {
            "state": true
        },
        "maxLines": {
            "type": Number,
            "attr": "max-lines"
        },
        "mode": {
            "type": String,
            "attr": "mode"
        },
        "regionDepth": {
            "type": Number,
            "attr": "region-depth"
        },
        "regions": {
            "type": "Any",
            "attr": "regions"
        },
        "saveFile": {
            "method": true
        },
        "selection": {
            "state": true
        },
        "setCursorPosition": {
            "method": true
        },
        "setLineNumber": {
            "method": true
        },
        "setSelection": {
            "method": true
        }
    }; }
    static get events() { return [{
            "name": "hexLineChanged",
            "method": "hexLineChanged",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }, {
            "name": "hexCursorChanged",
            "method": "hexCursorChanged",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }, {
            "name": "hexSelectionChanged",
            "method": "hexSelectionChanged",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }, {
            "name": "hexDataChanged",
            "method": "hexDataChanged",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }, {
            "name": "hexLoaded",
            "method": "hexLoaded",
            "bubbles": true,
            "cancelable": true,
            "composed": true
        }]; }
    static get style() { return "/**style-placeholder:fudge-hex-editor:**/"; }
}
